#!/usr/bin/python
# -*- encoding: utf-8 -*-

import sys
import time
from periphery import GPIO
from Adafruit_LED_Backpack import SevenSegment
import paho.mqtt.client as mqtt

# Initial setup

## Outputs and initial state

vent_red = GPIO(128, "out")
vent_green = GPIO(12, "out")
illum_red = GPIO(129, "out")
illum_green = GPIO(13, "out")
greenled = GPIO(43, "out")

outputs = [vent_red, vent_green, illum_red, illum_green]
for pin in outputs:
    pin.write(False)

hum_disp = SevenSegment.SevenSegment(address=0x70, busnum=6)
temp_disp = SevenSegment.SevenSegment(address=0x72, busnum=6)
light_disp = SevenSegment.SevenSegment(address=0x74, busnum=6)

hum_disp.begin()
temp_disp.begin()
light_disp.begin()

colon = False
previous_temp = 0
previous_hum = 0
previous_light = 0

illum_status = 'off'
vent_status = 'off'
system_mode = 'automatic'

## Test LEDs

for pin in outputs:
    pin.write(True)
    time.sleep(0.5)
    pin.write(False)

numbers = [0000, 1111, 2222, 3333, 4444, 5555, 6666, 7777, 8888, 9999]
displays = [hum_disp, temp_disp, light_disp]

for disp_module in displays:
    for i in numbers:
        disp_module.clear()
        disp_module.print_float(i, decimal_digits=0, justify_right=False)
        disp_module.set_colon(colon)
        disp_module.write_display()
        time.sleep(0.1)

## MQTT broker host

broker = "mosquitto"

# Hardware I/O functions

## Green LED:
## flash 2s = connected to broker
## single flash = message RX
## constant = failed to connect 

def indicate(mode):
    if mode == 'connected':
        for i in range(0, 20):
            greenled.write(True)
            time.sleep(0.1)
            greenled.write(False)
            time.sleep(0.1)
    elif mode == 'message':
            greenled.write(True)
            time.sleep(0.1)
            greenled.write(False)
    else:
        greenled.write(True)
    return

## Update temperature display

def update_temp(value):
    temp_disp.clear()
    temp_disp.print_float(value, decimal_digits=2)
    temp_disp.set_colon(colon)
    temp_disp.write_display()

def update_hum(value):
    hum_disp.clear()
    hum_disp.print_float(value, decimal_digits=2)
    hum_disp.set_colon(colon)
    hum_disp.write_display()

def update_light(value):
    light_disp.clear()
    light_disp.print_float(value, decimal_digits=0, justify_right=False)
    light_disp.set_colon(colon)
    light_disp.write_display()

## Update capacitive switch LEDs

def set_illum_ind(state):
    if state == 'on':
        if system_mode == 'automatic':
            illum_red.write(False)
            illum_green.write(True)
        elif system_mode =='manual':
            illum_red.write(True)
            illum_green.write(False)
    elif state == 'off':
        illum_red.write(False)
        illum_green.write(False)
    else:
        print "Invalid command"

def set_vent_ind(state):
    if state == 'on':
        if system_mode == 'automatic':
            vent_red.write(False)
            vent_green.write(True)
        elif system_mode =='manual':
            vent_red.write(True)
            vent_green.write(False)
    elif state == 'off':
        vent_red.write(False)
        vent_green.write(False)
    else:
        print "Invalid command"

# MQTT

## The callback for when the client receives a CONNACK response from the server.

def on_connect(client, userdata, flags, rc):
        print("Connected with result code "+str(rc))
        client.subscribe([("sensor/#", 0), ("actuator/#", 0), ("greenhouse/mode", 0)])
        indicate('connected')

## The callback for when a PUBLISH message is received from the server.

def on_message(client, userdata, msg):
        indicate('message')
        if msg.topic.startswith( 'sensor'):
            topic = msg.topic.lstrip('sensor/')
        elif msg.topic.startswith('actuator'):
            topic = msg.topic.lstrip('actuator/')
        elif msg.topic.startswith('greenhouse'):
            topic = msg.topic.lstrip('greenhouse/')
        else:
            return
        if topic == 'temperature':
            global previous_temp
            if msg.payload != previous_temp:
                update_temp(float(msg.payload))
                previous_temp = msg.payload
        elif topic == 'humidity':
            global previous_hum
            if msg.payload != previous_hum:
                update_hum(float(msg.payload))
                previous_hum = msg.payload
        elif topic == 'luminosity':
            global previous_light
            if msg.payload != previous_light:
                update_light(float(msg.payload))
                previous_light = msg.payload
        elif topic == 'illumination':
            global illum_status
            if msg.payload != illum_status:
                set_illum_ind(msg.payload)
                illum_status = msg.payload
        elif topic == 'ventillation':
            global vent_status
            if msg.payload != vent_status:
                set_vent_ind(msg.payload)
                vent_status = msg.payload
        elif topic == 'mode':
            global system_mode
            if msg.payload != system_mode:
                print "Set mode to: ", msg.payload
                system_mode = msg.payload
                set_illum_ind(illum_status)
                set_vent_ind(vent_status)
        else:
            return

## Setup client

client = mqtt.Client(client_id="console_indicators", clean_session=True)
client.on_connect = on_connect
client.on_message = on_message

## Connect and keep retrying on failure

try:
    client.connect(broker, 1883, 60)
except (KeyboardInterrupt, SystemExit):
    raise
except:
    print "Failed to connect to broker"
    indicate("fail")
    time.sleep(1)

## Run loop and wait for messages

client.loop_forever()
